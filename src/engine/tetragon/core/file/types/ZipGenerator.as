/* *      _________  __      __ *    _/        / / /____ / /________ ____ ____  ___ *   _/        / / __/ -_) __/ __/ _ `/ _ `/ _ \/ _ \ *  _/________/  \__/\__/\__/_/  \_,_/\_, /\___/_//_/ *                                   /___/ *  * Tetragon : Game Engine for multi-platform ActionScript projects. * http://www.tetragonengine.com/ - Copyright (C) 2012 Sascha Balkau *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */package tetragon.core.file.types{	import tetragon.core.constants.Status;	import tetragon.core.constants.ZipConstants;	import tetragon.util.compr.Deflate;	import flash.utils.ByteArray;	import flash.utils.Dictionary;			/**	 * A helper class that is used by the ZipFile class to generate zipped content.	 * 	 * @see com.hexagonstar.file.types.ZipFile	 */	public class ZipGenerator	{		//-----------------------------------------------------------------------------------------		// Properties		//-----------------------------------------------------------------------------------------				/** @private */		private var _zipFile:ZipFile;		/** @private */		private var _content:ByteArray;		/** @private */		private var _fileList:Array;		/** @private */		private var _paths:Dictionary;		/** @private */		private var _deflate:Deflate;		/** @private */		private var _crc:CRC32;		/** @private */		private var _autoCompression:Boolean;		/** @private */		private var _finalized:Boolean;						//-----------------------------------------------------------------------------------------		// Constructor		//-----------------------------------------------------------------------------------------				/**		 * Creates a new instance of the class.		 * 		 * @param zipFile The ZipFile that uses this ZipGenerator.		 * @param content The zip file content.		 * @param fileList The list with zip entries.		 * @param autoCompression Whether auto compression is used or not.		 */		function ZipGenerator(zipFile:ZipFile, content:ByteArray, fileList:Array,			autoCompression:Boolean)		{			_zipFile = zipFile;			_content = content;			_fileList = fileList;			_autoCompression = autoCompression;			_finalized = false;						_deflate = new Deflate();			_paths = new Dictionary();			_crc = new CRC32();		}						//-----------------------------------------------------------------------------------------		// Public Methods		//-----------------------------------------------------------------------------------------				/**		 * Adds a zip entry to a generated zip file content.		 * 		 * @private		 */		internal function addEntry(e:ZipEntry):Boolean		{			/* Set time stamp */			if (e.dostime == 0)			{				e.time = new Date().time;			}						/* Default to DEFLATE if nothing was set and auto compress is off! */
			if (!_autoCompression && e.compressionMethod == -1)			{				e.compressionMethod = ZipConstants.DEFLATE;			}						/* Compress the entry data */
			var compressedData:ByteArray = compressData(e);
						switch (e.compressionMethod)			{				case ZipConstants.DEFLATE:					if (isNaN(e.size) || isNaN(e.compressedSize) || e.crc32 == 0)					{						/* store size, compressed size, and crc-32 in data descriptor						 * immediately following the compressed entry data */						e.flag = 8;					}					else if (!isNaN(e.size) && !isNaN(e.compressedSize) && e.crc32 != 0)					{						/* store size, compressed size, and crc-32 in LOC header */						e.flag = 0;					}					else
					{
						error("Missing size, compressed size, or CRC32 in DEFLATE entry <"							+ e.path + "> for zip file <" + _zipFile.path + ">.");						return false;					}					e.version = 20;					break;								case ZipConstants.STORE:					/* compressed size, uncompressed size, and CRC32 must all be					 * set for entries using STORED compression method */					if (compressedData)					{						e.size = e.compressedSize = compressedData.length;						_crc.update(compressedData);						e.crc32 = _crc.value;					}					else					{						/* Entry is a folder! */						e.size = e.compressedSize = e.crc32 = 0;					}					e.version = 10;					e.flag = 0;					break;								default:					error("Unsupported compression method " + e.compressionMethod						+ " in entry <" + e.path + "> for zip file <" + _zipFile.path + ">.");					return false;			}						/* Store entry zipfile offset */			e.offset = _content.position;						/* Check if entry with same path already exists */			if (_paths[e.path] != null)
			{
				error("Duplicate entry <" + e.path + "> for zip file <" + _zipFile.path + ">.");				return false;			}			else			{				_paths[e.path] = e;			}						writeLOC(e);						if (writeData(e, compressedData))			{				if (closeEntry(e))				{					_fileList.push(e);					return true;				}			}						return false;		}						/**		 * @private		 */		internal function finalize(comment:String = null):void		{			var offset:uint = _content.position;			var folders:Array = [];			var files:Array = [];			var f:ZipEntry;						/*			// NOTE: Add sorting later (like 7zip is doing it).			for each (f in _fileList)			{				if (f.isDirectory) folders.push(f);				else files.push(f);
			}
			folders.sortOn("path", Array.CASEINSENSITIVE);			files.sortOn("path", Array.CASEINSENSITIVE);			_fileList = [];			_fileList = _fileList.concat(folders, files);			*/						/* Write central directory */			for (var i:int = 0; i < _fileList.length; i++)			{				writeCEN(_fileList[i]);			}						writeEND(offset, _content.position - offset, comment);						_zipFile.bytesLoaded = _content.length;			_zipFile.setStatus(true, Status.OK);			_finalized = true;		}						//-----------------------------------------------------------------------------------------		// Getters & Setters		//-----------------------------------------------------------------------------------------				/**		 * Whether the generated zip is finalized or not. A finalized zip has it's		 * CEN and END header added and no more entries can be added after that.		 * 		 * @private		 */		internal function get finalized():Boolean		{			return _finalized;		}						//-----------------------------------------------------------------------------------------		// Private Methods		//-----------------------------------------------------------------------------------------				/**		 * @private		 */		private function compressData(e:ZipEntry):ByteArray
		{			/* Data is either null, 0-byte or STORE, we return the given data to be used */			if (e.data == null || e.data.length == 0 || e.compressionMethod == ZipConstants.STORE)			{				e.compressionMethod = ZipConstants.STORE;				return e.data;			}						var buffer:ByteArray = new ByteArray();			_deflate.process(e.data, buffer);						/* Check if all went OK with deflating, if not we use STORE. */
			if (!_deflate.valid)
			{
				error(_deflate.status);				_deflate.reset();				_crc.reset();				e.compressionMethod = ZipConstants.STORE;				return e.data;			}						/* Auto Compression: Check if resulting data is actually smaller. */			if (_autoCompression)			{				if (buffer.length < e.data.length)				{					e.compressionMethod = ZipConstants.DEFLATE;					return buffer;				}				else				{					e.compressionMethod = ZipConstants.STORE;					return e.data;				}			}			else
			{
				e.compressionMethod = ZipConstants.DEFLATE;			}						return buffer;		}						/**		 * Writes data into the buffer for files added for zip generation.		 * 		 * @private		 * @return true if successful, false if not.		 */		private function writeData(e:ZipEntry, data:ByteArray):Boolean		{			/* Entry is an empty folder so don't try to store any data. */			if (data == null) return true;						try			{				_content.writeBytes(data);			}			catch (err:Error)
			{
				error(err.message);				return false;			}						_crc.update(e.data);			return true;		}						/**		 * @private		 * @return true if successful, false if not.		 */		private function closeEntry(e:ZipEntry):Boolean
		{			var success:Boolean = true;
			if (e.compressionMethod == ZipConstants.DEFLATE)			{				/* Size, compressed size, and CRC32 is stored in LOC header */				if ((e.flag & 8) == 0)				{					/* Verify size, compressed size, and CRC32 settings */					if (e.size != _deflate.inputBytes)					{						error("Invalid size for entry <" + e.path + "> during generation (expected "							+ e.size + " but got " + _deflate.inputBytes + " bytes).");						success = false;					}					if (e.compressedSize != _deflate.outputBytes)					{						error("Invalid compressed size for entry <" + e.path + "> during generation"							+ " (expected " + e.compressedSize + " but got " + _deflate.outputBytes							+ " bytes).");						success = false;					}					if (e.crc32 != _crc.value)					{						error( "Invalid CRC32 checksum for entry <" + e.path + "> during generation"							+ " (expected 0x" + e.crc32 + " but got 0x" + _crc.value + ").");						success = false;					}				}				/* Size, compressed size, and CRC32 is stored in data descriptor				 * immediately following the compressed entry data. */				else				{					e.size = _deflate.inputBytes;					e.compressedSize = _deflate.outputBytes;					e.crc32 = _crc.value;					writeEXT(e);				}			}			else if (e.compressionMethod == ZipConstants.STORE)			{				/* Nothing to do here for STORE. */			}						_deflate.reset();			_crc.reset();			
			return success;		}						/**		 * Writes local file header.		 * -----------------------------------------------------		 * local file header signature     4 bytes  (0x04034b50)		 * version needed to extract       2 bytes		 * general purpose bit flag        2 bytes		 * compression method              2 bytes		 * last mod file time              2 bytes		 * last mod file date              2 bytes		 * crc-32                          4 bytes		 * compressed size                 4 bytes		 * uncompressed size               4 bytes		 * file name length                2 bytes		 * extra field length              2 bytes		 * 		 * file name (variable size)		 * extra field (variable size)		 * 		 * @private		 */		private function writeLOC(e:ZipEntry):void		{			_content.writeUnsignedInt(ZipConstants.LOCSIG);			_content.writeShort(e.version);			_content.writeShort(e.flag);			_content.writeShort(e.compressionMethod);			_content.writeUnsignedInt(e.dostime);						if ((e.flag & 8) == 8)			{				/* Store CRC32, uncompressed size and uncompressed size in data				 * descriptor immediately following compressed entry data. */				_content.writeUnsignedInt(0);				_content.writeUnsignedInt(0);				_content.writeUnsignedInt(0);			}			else			{				_content.writeUnsignedInt(e.crc32);				_content.writeUnsignedInt(e.compressedSize);				_content.writeUnsignedInt(e.size);			}						_content.writeShort(e.path.length);			_content.writeShort(e.extra != null ? e.extra.length : 0);			_content.writeUTFBytes(e.path);						if (e.extra != null)			{				_content.writeBytes(e.extra);			}		}						/**		 * Writes extra data descriptor (EXT) for specified entry.		 * -------------------------------------------------------		 * crc-32                          4 bytes		 * compressed size                 4 bytes		 * uncompressed size               4 bytes		 * 		 * This descriptor exists only if bit 3 of the general purpose bit flag is set.		 * It is byte aligned and immediately follows the last byte of compressed data.		 * This descriptor is used only when it was not possible to seek in the output		 * .ZIP file, e.g., when the output .ZIP file was standard output or a non seekable		 * device.		 * 		 * @private		 */		private function writeEXT(e:ZipEntry):void		{			_content.writeUnsignedInt(ZipConstants.EXTSIG);			_content.writeUnsignedInt(e.crc32);			_content.writeUnsignedInt(e.compressedSize);			_content.writeUnsignedInt(e.size);		}						/**		 * Write central directory (CEN) header for specified entry.		 * REMINDER: add support for file attributes		 * ---------------------------------------------------------		 * central file header signature   4 bytes  (0x02014b50)		 * version made by                 2 bytes		 * version needed to extract       2 bytes		 * general purpose bit flag        2 bytes		 * compression method              2 bytes		 * last mod file time              2 bytes		 * last mod file date              2 bytes		 * crc-32                          4 bytes		 * compressed size                 4 bytes		 * uncompressed size               4 bytes		 * file name length                2 bytes		 * extra field length              2 bytes		 * file comment length             2 bytes		 * disk number start               2 bytes		 * internal file attributes        2 bytes		 * external file attributes        4 bytes		 * relative offset of local header 4 bytes		 * 		 * file name (variable size)		 * extra field (variable size)		 * file comment (variable size)		 * 		 * Digital signature:		 * header signature                4 bytes  (0x05054b50)		 * size of data                    2 bytes		 * signature data (variable size)		 * 		 * @private		 */		private function writeCEN(e:ZipEntry):void		{			_content.writeUnsignedInt(ZipConstants.CENSIG);			_content.writeShort(e.version);				// version made by			_content.writeShort(e.version);				// version needed to extract			_content.writeShort(e.flag);				// general purpose bit flag			_content.writeShort(e.compressionMethod);			_content.writeUnsignedInt(e.dostime);		// last modification time			_content.writeUnsignedInt(e.crc32);			_content.writeUnsignedInt(e.compressedSize);			_content.writeUnsignedInt(e.size);			_content.writeShort(e.path.length);			_content.writeShort(e.extra != null ? e.extra.length : 0);			_content.writeShort(e.comment != null ? e.comment.length : 0);			_content.writeShort(0);						// starting disk number			_content.writeShort(0);						// internal file attributes (unused)			_content.writeUnsignedInt(0);				// external file attributes (unused)			_content.writeUnsignedInt(e.offset);		// relative offset of local header			_content.writeUTFBytes(e.path);						if (e.extra != null)			{				_content.writeBytes(e.extra);			}			if (e.comment != null)			{				_content.writeUTFBytes(e.comment);			}		}						/**		 * Writes end of central directory (END) header.		 * -----------------------------------------------------		 * end of central dir signature    4 bytes  (0x06054b50)		 * number of this disk             2 bytes		 * number of the disk with the		 * start of the central directory  2 bytes		 * total number of entries in the		 * central directory on this disk  2 bytes		 * total number of entries in		 * the central directory           2 bytes		 * size of the central directory   4 bytes		 * offset of start of central		 * directory with respect to		 * the starting disk number        4 bytes		 * .ZIP file comment length        2 bytes		 * .ZIP file comment       (variable size)		 * 		 * @private		 */		private function writeEND(offset:uint, len:uint, comment:String):void		{			if (comment == null) comment = "";			_content.writeUnsignedInt(ZipConstants.ENDSIG);			_content.writeShort(0);						// number of this disk			_content.writeShort(0);						// central directory start disk			_content.writeShort(_fileList.length);		// number of directory entries on disk			_content.writeShort(_fileList.length);		// total number of directory entries			_content.writeUnsignedInt(len);				// length of central directory			_content.writeUnsignedInt(offset);			// offset of central directory			_content.writeShort(comment.length);		// zip file comment length			_content.writeUTF(comment);					// zip file comment		}						/**		 * @private		 */		private function error(msg:String):void		{			_zipFile.error(msg);		}
	}}import flash.utils.ByteArray;// -------------------------------------------------------------------------------------------------/** * Helper class to generate and store CRC checksums for zip output generation. * @private */final class CRC32{	private var _crc:uint;	private static var _crcTable:Vector.<uint>;		public function CRC32()	{		/* Lazy instantiation on first use! */		if (!CRC32._crcTable)		{			CRC32._crcTable = makeCrcTable();		}	}		public function reset():void	{		_crc = 0;	}		public function update(buffer:ByteArray):void	{		var off:uint = 0;		var len:uint = buffer.length;		var c:uint = ~_crc;		while (--len >= 0)		{			c = _crcTable[(c ^ buffer[off++]) & 0xff] ^ (c >>> 8);		}		_crc = ~c;	}		public function get value():uint	{		return _crc & 0xffffffff;	}		private static function makeCrcTable():Vector.<uint>	{		var crcTable:Vector.<uint> = new Vector.<uint>(256);		for (var n:int = 0; n < 256; n++)		{			var c:uint = n;			for (var k:int = 8; --k >= 0;)			{				if ((c & 1) != 0) c = 0xedb88320 ^ (c >>> 1);				else c = c >>> 1;			}			crcTable[n] = c;		}		return crcTable;	}}