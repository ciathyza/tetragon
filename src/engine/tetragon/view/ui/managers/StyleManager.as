/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package tetragon.view.ui.managers{	import tetragon.view.ui.core.UIComponent;	import flash.text.TextFormat;	import flash.utils.Dictionary;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	import flash.utils.getQualifiedSuperclassName;		/**	 * The StyleManager class provides static methods that can be used to get and 	 * set styles for a component instance, an entire component type, or all user 	 * interface components in a Flash document. Styles are defined as values that 	 * affect the display of a component, including padding, text formats, and skins.	 */	public class StyleManager	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				private static var _instance:StyleManager;				private var _styleToClassesHash:Object;		private var _classToInstDict:Dictionary;		private var _classToStylesDict:Dictionary;		private var _classToDefStylesDict:Dictionary;		private var _globalStyles:Object;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new StyleManager instance.		 */		public function StyleManager()		{			_styleToClassesHash = {};			_classToInstDict = new Dictionary(true);			_classToStylesDict = new Dictionary(true);			_classToDefStylesDict = new Dictionary(true);			_globalStyles = UIComponent.styleDefinition;		}						/**		 * Registers a component instance with the style manager. After a component		 * instance is instantiated, it can register with the style manager to be		 * notified of changes in style. Component instances can register to receive		 * notice of style changes that are component-based or global in nature.		 *		 * @param inst The component instance to be registered for style management.		 */		public static function registerInstance(inst:UIComponent):void		{			var i:StyleManager = instance;			var classDef:Class = getClassDef(inst);						if (!classDef) return;						/* check if an instance of this class has been registered before */			if (!i._classToInstDict[classDef])			{				i._classToInstDict[classDef] = new Dictionary(true);								/* set up the style to class hash. This lets us look up which				 * classes use which styles quickly. */				var target:Class = classDef;				var defaultStyles:Object;								/* Walk the inheritance chain looking for a default styles object. */				while (!defaultStyles)				{					/* Trick the strict compiler. */					if (target["styleDefinition"])					{						defaultStyles = target["styleDefinition"];						break;					}					try					{						target = inst.loaderInfo.applicationDomain.							getDefinition(getQualifiedSuperclassName(target)) as Class;					}					catch (e:Error)					{						try						{							target = getDefinitionByName(getQualifiedSuperclassName(target))								as Class;						}						catch (e:Error)						{							defaultStyles = UIComponent.styleDefinition;							break;						}					}				}								var styleToClasses:Object = i._styleToClassesHash;				for (var n:String in defaultStyles)				{					if (!styleToClasses[n]) styleToClasses[n] = new Dictionary(true);					/* add this class as a subscriber to this style */					styleToClasses[n][classDef] = true;				}								/* add this class's default styles */				i._classToDefStylesDict[classDef] = defaultStyles;				if (!i._classToStylesDict[classDef])				{					/* set up the override styles table */					i._classToStylesDict[classDef] = {};				}			}						i._classToInstDict[classDef][inst] = true;			setSharedStyles(inst);		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns a Singleton instance of StyleManager.		 */		public static function get instance():StyleManager		{			if (!_instance) _instance = new StyleManager();			return _instance;		}						/**		 * Gets a style that exists on a specific component.		 * 		 * @param component The name of the component instance on which to find the		 *         requested style.		 * @param name The name of the style to be retrieved.		 * @return The requested style from the specified component. This function		 *          returns <code>null</code> if the specified style is not found.		 * 		 * @see #clearComponentStyle()		 * @see #getStyle()		 * @see #setComponentStyle()		 */		public static function getComponentStyle(component:Object, name:String):Object		{			var styleHash:Object = instance._classToStylesDict[getClassDef(component)];			return (!styleHash) ? null : styleHash[name];		}						/**		 * Removes a style from the specified component.		 * 		 * @param component The name of the component from which the style is to be removed.		 * @param name The name of the style to be removed.		 * 		 * @see #clearStyle()		 * @see #getComponentStyle()		 * @see #setComponentStyle()		 */		public static function clearComponentStyle(component:Object, name:String):void		{			var classDef:Class = getClassDef(component);			var styleHash:Object = instance._classToStylesDict[classDef];						if (styleHash && styleHash[name])			{				delete(styleHash[name]);				invalidateComponentStyle(classDef, name);			}		}						/**		 * Sets a style on all instances of a component type, for example, on all		 * instances of a Button component, or on all instances of a ComboBox component.		 * 		 * @param component The type of component, for example, Button or ComboBox.		 *         This parameter also accepts a component instance or class that can		 *         be used to identify all instances of a component type.		 * @param name The name of the style to be set.		 * @param style The style object that describes the style that is to be set.		 * 		 * @see #clearComponentStyle()		 * @see #getComponentStyle()		 * @see #setStyle()		 */		public static function setComponentStyle(component:Object,													  name:String,													  style:Object):void		{			var classDef:Class = getClassDef(component);			var styleHash:Object = instance._classToStylesDict[classDef];						if (!styleHash) styleHash = instance._classToStylesDict[classDef] = {};			if (styleHash == style) return;						styleHash[name] = style;			invalidateComponentStyle(classDef, name);		}						/**		 * Sets a global style for all user interface components in a document.		 * 		 * @param name A String value that names the style to be set.		 * @param style The style object to be set. The value of this property depends on the 		 * style that the user sets. For example, if the style is set to "textFormat", the style 		 * property should be set to a TextFormat object. A mismatch between the style name and		 * the value of the style property may cause the component to behave incorrectly.		 * 		 * @see #clearStyle()		 * @see #getStyle()		 * @see #setComponentStyle()		 */		public static function setStyle(name:String, style:Object):void		{			var styles:Object = instance._globalStyles;			if (styles[name] === style && !(style is TextFormat)) return;			styles[name] = style;			invalidateStyle(name);		}						/**		 * Gets a global style by name.		 * 		 * @param name The name of the style to be retrieved.		 * @return The value of the global style that was retrieved.		 * 		 * @see #clearStyle()		 * @see #getComponentStyle()		 * @see #setStyle()		 */		public static function getStyle(name:String):Object		{			return instance._globalStyles[name];		}						/**		 * Removes a global style from all user interface components in a document.		 * 		 * @param name The name of the global style to be removed.		 * 		 * @see #clearComponentStyle()		 * @see #getStyle()		 * @see #setStyle()		 */		public static function clearStyle(name:String):void		{			setStyle(name, null);		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Sets an inherited style on a component.		 * @private		 * 		 * @param inst The component object on which to set the inherited style.		 */		private static function setSharedStyles(inst:UIComponent):void		{			var styles:Object = instance._classToDefStylesDict[getClassDef(inst)];			for (var n:String in styles)			{				inst.setSharedStyle(n, getSharedStyle(inst, n));			}		}						/**		 * @private		 */		private static function getSharedStyle(inst:UIComponent, name:String):Object		{			var classDef:Class = getClassDef(inst);			var i:StyleManager = instance;						/* first check component styles */			var style:Object = i._classToStylesDict[classDef][name];			if (style) return style;						/* then check global styles */			style = i._globalStyles[name];			if (style) return style;						/* finally return the default component style */			return i._classToDefStylesDict[classDef][name];		}						/**		 * @private		 */		private static function invalidateStyle(name:String):void		{			var classes:Dictionary = instance._styleToClassesHash[name];			if (!classes) return;						for (var classRef:Object in classes)			{				invalidateComponentStyle(Class(classRef), name);			}		}						/**		 * @private		 */		private static function invalidateComponentStyle(compClass:Class,name:String):void		{			var instances:Dictionary = instance._classToInstDict[compClass];			if (!instances) return;						for (var o:Object in instances)			{				var inst:UIComponent = o as UIComponent;				if (!inst) continue;				inst.setSharedStyle(name, getSharedStyle(inst, name));			}		}						/**		 * @private		 */		private static function getClassDef(component:Object):Class		{			if (component is Class)			{				return (component as Class);			}			try			{				return getDefinitionByName(getQualifiedClassName(component)) as Class;			}			catch (e:Error)			{				if (component is UIComponent)				{					try					{						return UIComponent(component).loaderInfo.applicationDomain.							getDefinition(getQualifiedClassName(component)) as Class;					}					catch (e:Error)					{					}				}			}			return null;		}	}}