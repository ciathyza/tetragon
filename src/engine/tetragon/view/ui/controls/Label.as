/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package tetragon.view.ui.controls{	import tetragon.view.ui.constants.InvalidationType;	import tetragon.view.ui.constants.UIStyles;	import tetragon.view.ui.core.UIComponent;	import tetragon.view.ui.event.UIComponentEvent;	import flash.text.AntiAliasType;	import flash.text.GridFitType;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.text.TextFormat;			[Event(name="resize", type="tetragon.view.ui.event.UIComponentEvent")]	[Style(name="textFormat", type="flash.text.TextFormat")]	[Style(name="embedFonts", type="Boolean")]			/**	 * A Label component displays one or more lines of plain or 	 * HTML-formatted text that can be formatted for alignment and	 * size. Label components do not have borders and cannot receive 	 * focus.	 *	 * <p>A live preview of each Label instance reflects the changes	 * that were made to parameters in the Property inspector or Component	 * inspector during authoring. Because a Label component does not have a border,	 * the only way to see the live preview for a Label instance is to set 	 * its <code>text</code> property. The <code>autoSize</code> property is not supported 	 * in live preview.</p>	 */	public class Label extends UIComponent	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _tf:TextField;		protected var _actualWidth:Number;		protected var _actualHeight:Number;		protected var _defaultText:String = "";		protected var _savedHTML:String;		protected var _isHTML:Boolean = false;				private static var _defaultStyles:Object =		{			textFormat: null,			embedFonts: false		};						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new Label instance.		 * 		 * If no width or height is specified (w/h = -1) the label tries to match		 * the size of it's text contents if autoSize is set to none.		 * 		 * @param width Width of the label.		 * @param height Height of the label.		 */		public function Label(width:Number = -1, height:Number = -1)		{			super();						text = _defaultText;			_actualWidth = _width = width;			_actualHeight = _height = height;		}						/**		 * @copy com.hexagonstar.ui.core.HUIComponent#setSize()		 */		override public function setSize(width:Number, height:Number):void		{			_actualWidth = width;			_actualHeight = height;			super.setSize(width, height);		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @copy com.hexagonstar.ui.core.HUIComponent#getStyleDefinition()		 *		 * @see com.hexagonstar.ui.core.HUIComponent#getStyle() HUIComponent#getStyle()		 * @see com.hexagonstar.ui.core.HUIComponent#setStyle() HUIComponent#setStyle()		 * @see com.hexagonstar.ui.managers.StyleManager StyleManager		 */		public static function get styleDefinition():Object		{ 			return _defaultStyles;		}						/**		 * Gets or sets the plain text to be displayed by the Label component.		 * <p>Note that characters that represent HTML markup have no special 		 * meaning in the string and will appear as they were entered.</p>		 * <p>To display text that contains HTML tags, use the <code>htmlText</code>		 * property. The HTML replaces any text that you set by using the <code>htmlText</code> 		 * property, and the <code>text</code> property returns a plain text version of 		 * the HTML text, with the HTML tags removed.</p>		 * <p>If the <code>text</code> property is changed from the default value in the		 * property inspector, it takes precedence over the <code>htmlText</code> 		 * property in the property inspector.</p>		 *		 * @see #htmlText		 * @see flash.text.TextField#text		 */ 		public function get text():String		{			return _tf.text;		}				public function set text(v:String):void		{			/* Value is the same as what is already set. */			if (v == _tf.text) return;			/* Clear the HTML value, and redraw. */			_isHTML = false;			_tf.text = v ? v : "";			invalidateOnAutoSize();		}						/**		 * Gets or sets the text to be displayed by the Label component, including 		 * HTML markup that expresses the styles of that text. You can specify HTML		 * text in this property by using the subset of HTML tags that are supported		 * by the TextField object.		 * <p>If the default value of the <code>text</code> property is changed in the		 * Property inspector, this changed value takes precedence over any value in the 		 * <code>htmlText</code> property field in the Property inspector. To use the 		 * <code>htmlText</code> property in the Property inspector, the <code>text</code> property		 * field must contain the value <code>Label</code>, exactly as shown. When coding with 		 * ActionScript, you do not need to set the value of the <code>text</code> property; the 		 * default value is <code>Label</code>.</p>		 * 		 * @see #text		 * @see flash.text.TextField#htmlText		 */		public function get htmlText():String		{			return _tf.htmlText;		}				public function set htmlText(v:String):void		{			/* Value is the same as what is already set. */			if (v == htmlText) return;			/* Remember the html for later. */			_isHTML = true;			_savedHTML = v;			/* Change the text, and possibly resize. */			_tf.htmlText = v;			invalidateOnAutoSize();		}						/**		 * Gets or sets a value that indicates whether extra white space such as spaces 		 * and line breaks should be removed from a Label component that contains HTML text. 		 * A value of <code>true</code> indicates that white space is to be removed; a		 * value of <code>false</code> indicates that it remains.		 * <p>The <code>condenseWhite</code> property affects only text that was set by 		 * using the <code>htmlText</code> property, not the <code>text</code> property. 		 * If you set text by using the <code>text</code> property, the <code>condenseWhite</code> 		 * property is ignored.</p>		 * <p>If you set the <code>condenseWhite</code> property to <code>true</code>, 		 * you must use standard HTML commands, such as &lt;br&gt; and &lt;p&gt;, to break		 * the lines of the text in the text field.</p>		 *		 * @see #htmlText		 * @see flash.text.TextField#condenseWhite		 */				public function get condenseWhite():Boolean		{			return _tf.condenseWhite;		}				public function set condenseWhite(v:Boolean):void		{			_tf.condenseWhite = v;			invalidateOnAutoSize();		}						/**		 * Gets or sets a value that indicates whether the text can be selected. A value 		 * of <code>true</code> indicates that it can be selected; a value of <code>false</code> 		 * indicates that it cannot. 		 * <p>Text that can be selected can be copied from the Label component by the user.</p> 		 */	    		public function get selectable():Boolean 		{			return _tf.selectable;		}						public function set selectable(v:Boolean):void		{			_tf.selectable = v;		}						/**		 * Gets or sets a value that indicates whether the text field supports word wrapping.		 * A value of <code>true</code> indicates that it does; a value of <code>false</code>		 * indicates that it does not.		 */				public function get wordWrap():Boolean		{			return _tf.wordWrap;		}				public function set wordWrap(value:Boolean):void		{			_tf.wordWrap = value;			invalidateOnAutoSize();		}						/**		 * Gets or sets a string that indicates how a label is sized and aligned to		 * fit the value of its <code>text</code> property. The following are		 * valid values:		 * <ul>		 *     <li><code>TextFieldAutoSize.NONE</code>: The label is not resized or aligned		 *     to fit the text.</li>		 *     <li><code>TextFieldAutoSize.LEFT</code>: The right and bottom sides of the		 *     label are resized to fit the text.		 *	       The left and top sides are not resized.</li>		 *     <li><code>TextFieldAutoSize.CENTER</code>: The left and right sides of the		 *     label resize to fit the text.		 *	       The horizontal center of the label stays anchored at its original horizontal		 *	       center position.</li>		 *     <li><code>TextFieldAutoSize.RIGHT</code>: The left and bottom sides of the		 *     label are resized to fit the text. The top and right sides are not resized.</li>		 *  </ul>		 *		 * @see flash.text.TextFieldAutoSize TextFieldAutoSize		 */				public function get autoSize():String		{			return _tf.autoSize;		}				public function set autoSize(v:String):void		{			_tf.autoSize = v;			invalidate(InvalidationType.SIZE);		}						/**		 * @copy com.hexagonstar.ui.core.HUIComponent#width		 *		 * @see #height		 * @see com.hexagonstar.ui.core..HUIComponent#setSize()		 */		override public function get width():Number		{			if (_tf.autoSize != TextFieldAutoSize.NONE && !wordWrap) return _width;			else return _actualWidth;		}				override public function set width(v:Number):void		{			_actualWidth = v;			super.width = v;		}						/**		 * @copy com.hexagonstar.ui.core.HUIComponent#height		 *		 * @see #height		 * @see com.hexagonstar.ui.core..HUIComponent#setSize()		 */		override public function get height():Number		{			if (_tf.autoSize != TextFieldAutoSize.NONE && wordWrap) return _height;			else return _actualHeight;		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		override protected function configUI():void		{			super.configUI();						_tf = new TextField();			_tf.type = TextFieldType.DYNAMIC;			_tf.selectable = false;			_tf.wordWrap = false;			_tf.antiAliasType = AntiAliasType.ADVANCED;			_tf.gridFitType = GridFitType.PIXEL;			addChild(_tf);		}						/**		 * @private		 */		override protected function draw():void		{			if (isInvalid(InvalidationType.STYLES, InvalidationType.STATE))			{				drawTextFormat();								_tf.embedFonts = getStyleValue(UIStyles.EMBED_FONTS) as Boolean;								if (_tf.autoSize != TextFieldAutoSize.NONE)					invalidate(InvalidationType.SIZE, false);			}						if (isInvalid(InvalidationType.SIZE)) drawLayout();						super.draw();		}						/**		 * @private		 */		protected function drawTextFormat():void		{			var f:TextFormat = getStyleValue(UIStyles.TEXTFORMAT);			if (!f)			{				var uiStyles:Object = UIComponent.styleDefinition;				if (enabled) f = uiStyles[UIStyles.DEFAULT_TEXTFORMAT];				else f = uiStyles[UIStyles.DEFAULT_TEXTFORMAT_DISABLED];			}						/* This removes HTML Styles... */			_tf.defaultTextFormat = f;			_tf.setTextFormat(f);						/* Set the HTML again to make sure that the HTML styles are preserved. */			if (_isHTML && _savedHTML != null) htmlText = _savedHTML;		}						/**		 * @private		 */		protected function drawLayout():void		{			var isResized:Boolean = false;						/* Try to equal text size if we start with a 0 sized Label */			if (_tf.autoSize == TextFieldAutoSize.NONE)			{				if (_width < 0) width = _tf.textWidth + 4;				if (_height < 0) height = _tf.textHeight + 4;			}						_tf.width = width;			_tf.height = height;						if (_tf.autoSize != TextFieldAutoSize.NONE)			{				var txtW:Number = _tf.width;				var txtH:Number = _tf.height;								isResized = (_width != txtW || _height != txtH);				/* set the properties directly, so we don't trigger a callLater */				_width = txtW;				_height = txtH;								switch (_tf.autoSize)				{					case TextFieldAutoSize.CENTER:						_tf.x = (_actualWidth / 2) - (_tf.width / 2);						break;					case TextFieldAutoSize.LEFT:						_tf.x = 0;						break;					case TextFieldAutoSize.RIGHT:						_tf.x = -(_tf.width - _actualWidth);						break;				}			}			else			{				_tf.width = _actualWidth;				_tf.height = _actualHeight;				_tf.x = 0;			}						if (isResized)			{				dispatchEvent(new UIComponentEvent(UIComponentEvent.RESIZE, true));			}		}						/**		 * Invalidates the Label if it is an autoSized Label.		 * @private		 */		protected function invalidateOnAutoSize():void		{			if (_tf.autoSize != TextFieldAutoSize.NONE) invalidate(InvalidationType.SIZE);		}	}}